# nps_mcp_server.py
# MCP server for the National Park Service APIs
# Enhanced with HTTP server support for remote testing
# Mostly generated by Cursor using Claude 4 Sonnet.

"""MCP server for the National Park Service APIs.

These APIs are documented at https://www.nps.gov/subjects/developer/api-documentation.htm

The NPS API provides access to:
- Parks: Location, contact, operating hours, and entrance fee information
- Alerts: Announcements about hazardous or changing conditions
- Campgrounds: Location, contact, operating hours, site amenities, and fee information
- Events: Date, time, fee, and description of events in national parks
- Visitor Centers: Location, contact, and operating hours information
- News Releases: Title, abstract, and links to park news releases
- Articles: Titles, images, and descriptions of shared content articles

Authentication: Requires an API key passed via X-Api-Key header or api_key parameter
Rate Limits: 1,000 requests per hour per API key
"""

from typing import Optional
import httpx
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_http_request
from fastmcp.server.middleware import Middleware, MiddlewareContext, CallNext
from fastmcp.server.middleware.logging import LoggingMiddleware
from fastmcp.tools.tool import Tool
from starlette.requests import Request
from typing import Sequence
import mcp.types
import os
import argparse
import json
import logging
from dotenv import load_dotenv
from pathlib import Path

# Load environment variables from .env file (check both current dir and parent dir)
env_path = Path(__file__).parent.parent / ".env"
if env_path.exists():
    load_dotenv(env_path)
else:
    load_dotenv()  # Try current directory

# Logger will be configured after parsing command line arguments
logger = None

def get_logger():
    """Get the logger, creating a default one if not configured yet."""
    global logger
    if logger is None:
        # Create a default logger with WARNING level if not configured
        logger = configure_logging("WARNING")
    return logger

# Constants for the National Park Service API
NPS_API_BASE = "https://developer.nps.gov/api/v1"
USER_AGENT = "nps-mcp-server/1.0 (contact@example.com)"

# Get API key from environment variable
def configure_logging(log_level: str) -> logging.Logger:
    """Configure logging with the specified level."""
    global logger
    
    # Convert string level to logging constant
    numeric_level = getattr(logging, log_level.upper())
    
    # Configure root logger at WARNING level to suppress dependency logs
    logging.basicConfig(
        level=logging.WARNING,  # Keep dependencies quiet
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[
            logging.StreamHandler(),  # Console output
            logging.FileHandler("nps_mcp_server.log")  # File output
        ],
        force=True  # Override any existing configuration
    )
    
    # Set our specific logger to the requested level
    logger = logging.getLogger(__name__)
    logger.setLevel(numeric_level)
    
    # Also set the "nps" logger (from FastMCP) to the requested level if needed
    nps_logger = logging.getLogger("nps")
    nps_logger.setLevel(numeric_level)
    
    # Debug info for troubleshooting (can be removed later)
    if log_level == "DEBUG":
        print(f"Debug: Logger '{__name__}' set to {log_level} level")
        print("Debug: Dependency loggers remain at WARNING level")
    
    return logger

def mask_sensitive_headers(headers: dict) -> dict:
    """Create a copy of headers with sensitive values masked for logging."""
    masked_headers = headers.copy()
    sensitive_keys = ["X-Api-Key", "x-api-key", "Authorization", "authorization"]
    
    for key in masked_headers:
        if key in sensitive_keys:
            value = masked_headers[key]
            if len(value) > 8:
                # Show first 4 and last 4 characters with asterisks in between
                masked_headers[key] = f"{value[:4]}***{value[-4:]}"
            else:
                # For shorter values, just show asterisks
                masked_headers[key] = "***"
    
    return masked_headers

def get_api_key() -> str:
    """Get NPS API key from environment variable."""
    api_key = os.getenv("NPS_API_KEY")
    if not api_key:
        return "DEMO_KEY"  # NPS allows limited use with DEMO_KEY
    return api_key

class ListToolsLoggerMiddleware(Middleware):
    """Custom middleware to log when list-tools is called."""
    
    async def on_list_tools(
        self,
        context: MiddlewareContext[mcp.types.ListToolsRequest],
        call_next: CallNext[mcp.types.ListToolsRequest, Sequence[Tool]],
    ) -> Sequence[Tool]:
        # Log before processing
        get_logger().debug(f"list-tools called at {context.timestamp} (method: {context.method})")
        
        # Call the next middleware or core handler
        tools = await call_next(context)
        
        # Log after processing
        get_logger().debug(f"list-tools returned {len(tools)} tools")
        return tools

# Initialize FastMCP server
# The name "nps" is how this server will be identified by clients
mcp = FastMCP(name="nps", middleware=[LoggingMiddleware(logger=get_logger()), ListToolsLoggerMiddleware()])

@mcp.tool()
async def search_parks(
    state_code: Optional[str] = None, 
    park_code: Optional[str] = None,
    query: Optional[str] = None,
    limit: int = 10,
) -> str:
    """
    Search for national parks by state, park code, or query string.
    
    Args:
        state_code: Two-letter state code (e.g., 'CA', 'NY')
        park_code: Four-letter park code (e.g., 'yell', 'acad')
        query: Search query for park names or descriptions
        limit: Maximum number of results to return (default: 10)
    
    Returns:
        JSON string with park information including name, description, website, and location
    """
    # Log input parameters
    get_logger().debug(f"search_parks called with inputs: state_code={state_code}, park_code={park_code}, query={query}, limit={limit}")

    request: Request = get_http_request()
    headers = dict(request.headers)
    if headers:
        get_logger().debug(f"tool call headers: {mask_sensitive_headers(headers)}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/parks"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        
        params = {"limit": str(limit)}
        if state_code:
            params["stateCode"] = state_code.upper()
        if park_code:
            params["parkCode"] = park_code.lower()
        if query:
            params["q"] = query

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            parks = []
            for park in data["data"]:
                park_info = {
                    "name": park.get("fullName", ""),
                    "code": park.get("parkCode", ""),
                    "description": park.get("description", ""),
                    "website": park.get("url", ""),
                    "states": park.get("states", ""),
                    "designation": park.get("designation", ""),
                    "latitude": park.get("latitude", ""),
                    "longitude": park.get("longitude", "")
                }
                parks.append(park_info)
            
            result = json.dumps({
                "total": data.get("total", len(parks)),
                "parks": parks
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"search_parks returning success result with {len(parks)} parks")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({"message": "No parks found matching your criteria"})
            get_logger().debug(f"search_parks returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"search_parks HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"search_parks returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"search_parks returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"search_parks request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"search_parks returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"search_parks unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"search_parks returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_park_alerts(park_code: str) -> str:
    """
    Get current alerts for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
    
    Returns:
        JSON string with current alerts for the park
    """
    # Log input parameters
    get_logger().debug(f"get_park_alerts called with inputs: park_code={park_code}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/alerts"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower()}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            alerts = []
            for alert in data["data"]:
                alert_info = {
                    "title": alert.get("title", ""),
                    "category": alert.get("category", ""),
                    "description": alert.get("description", ""),
                    "url": alert.get("url", ""),
                    "parkCode": alert.get("parkCode", "")
                }
                alerts.append(alert_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalAlerts": len(alerts),
                "alerts": alerts
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_park_alerts returning success result with {len(alerts)} alerts")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No current alerts for this park"
            })
            get_logger().debug(f"get_park_alerts returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_park_alerts HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_park_alerts returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_alerts returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_park_alerts request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_alerts returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_park_alerts unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_alerts returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_park_campgrounds(park_code: str, limit: int = 10) -> str:
    """
    Get campground information for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
        limit: Maximum number of campgrounds to return (default: 10)
    
    Returns:
        JSON string with campground information including location, amenities, and fees
    """
    # Log input parameters
    get_logger().debug(f"get_park_campgrounds called with inputs: park_code={park_code}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/campgrounds"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower(), "limit": str(limit)}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            campgrounds = []
            for campground in data["data"]:
                campground_info = {
                    "name": campground.get("name", ""),
                    "description": campground.get("description", ""),
                    "latitude": campground.get("latitude", ""),
                    "longitude": campground.get("longitude", ""),
                    "reservationInfo": campground.get("reservationInfo", ""),
                    "reservationUrl": campground.get("reservationUrl", ""),
                    "regulationsUrl": campground.get("regulationsUrl", ""),
                    "parkCode": campground.get("parkCode", "")
                }
                campgrounds.append(campground_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalCampgrounds": len(campgrounds),
                "campgrounds": campgrounds
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_park_campgrounds returning success result with {len(campgrounds)} campgrounds")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No campgrounds found for this park"
            })
            get_logger().debug(f"get_park_campgrounds returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_park_campgrounds HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_park_campgrounds returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_campgrounds returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_park_campgrounds request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_campgrounds returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_park_campgrounds unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_campgrounds returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_park_events(park_code: str, limit: int = 10) -> str:
    """
    Get upcoming events for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
        limit: Maximum number of events to return (default: 10)
    
    Returns:
        JSON string with event information including date, time, fee, and description
    """
    # Log input parameters
    get_logger().debug(f"get_park_events called with inputs: park_code={park_code}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/events"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower(), "limit": str(limit)}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            events = []
            for event in data["data"]:
                event_info = {
                    "title": event.get("title", ""),
                    "description": event.get("description", ""),
                    "location": event.get("location", ""),
                    "dateStart": event.get("dateStart", ""),
                    "dateEnd": event.get("dateEnd", ""),
                    "timeStart": event.get("timeStart", ""),
                    "timeEnd": event.get("timeEnd", ""),
                    "feeInfo": event.get("feeInfo", ""),
                    "isRecurring": event.get("isRecurring", False),
                    "parkCode": event.get("parkCode", "")
                }
                events.append(event_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalEvents": len(events),
                "events": events
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_park_events returning success result with {len(events)} events")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No upcoming events found for this park"
            })
            get_logger().debug(f"get_park_events returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_park_events HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_park_events returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_events returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_park_events request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_events returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_park_events unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_park_events returning unexpected error: {result}")
        return result

@mcp.tool()
async def get_visitor_centers(park_code: str, limit: int = 10) -> str:
    """
    Get visitor center information for a specific national park.
    
    Args:
        park_code: Four-letter park code (e.g., 'yell', 'acad', 'grca')
        limit: Maximum number of visitor centers to return (default: 10)
    
    Returns:
        JSON string with visitor center information including location, contact, and operating hours
    """
    # Log input parameters
    get_logger().debug(f"get_visitor_centers called with inputs: park_code={park_code}, limit={limit}")
    
    try:
        api_key = get_api_key()
        url = f"{NPS_API_BASE}/visitorcenters"
        headers = {"X-Api-Key": api_key, "User-Agent": USER_AGENT}
        params = {"parkCode": park_code.lower(), "limit": str(limit)}

        # Log HTTP request details
        get_logger().debug(f"Making HTTP request to: {url}")
        get_logger().debug(f"Request headers: {mask_sensitive_headers(headers)}")
        get_logger().debug(f"Request params: {params}")

        async with httpx.AsyncClient() as client:
            response = await client.get(url, headers=headers, params=params)
            
            # Log HTTP response details
            get_logger().debug(f"HTTP response status: {response.status_code}")
            get_logger().debug(f"HTTP response headers: {dict(response.headers)}")
            
            response.raise_for_status()
            data = response.json()
            
            # Log raw API response (truncated for readability)
            get_logger().debug(f"Raw API response data (first 500 chars): {str(data)[:500]}...")

        if "data" in data and data["data"]:
            centers = []
            for center in data["data"]:
                center_info = {
                    "name": center.get("name", ""),
                    "description": center.get("description", ""),
                    "latitude": center.get("latitude", ""),
                    "longitude": center.get("longitude", ""),
                    "directionsInfo": center.get("directionsInfo", ""),
                    "directionsUrl": center.get("directionsUrl", ""),
                    "operatingHours": center.get("operatingHours", []),
                    "addresses": center.get("addresses", []),
                    "contacts": center.get("contacts", {}),
                    "parkCode": center.get("parkCode", "")
                }
                centers.append(center_info)
            
            result = json.dumps({
                "parkCode": park_code.upper(),
                "totalVisitorCenters": len(centers),
                "visitorCenters": centers
            }, indent=2)
            
            # Log successful output
            get_logger().debug(f"get_visitor_centers returning success result with {len(centers)} visitor centers")
            get_logger().debug(f"Output (first 300 chars): {result[:300]}...")
            return result
        else:
            result = json.dumps({
                "parkCode": park_code.upper(),
                "message": "No visitor centers found for this park"
            })
            get_logger().debug(f"get_visitor_centers returning no results: {result}")
            return result

    except httpx.HTTPStatusError as e:
        error_msg = f"HTTP error: {e.response.status_code} - {e.response.text}"
        get_logger().error(f"get_visitor_centers HTTP error: {error_msg}")
        if e.response.status_code == 429:
            result = json.dumps({"error": "Rate limit exceeded. Please try again later."})
            get_logger().debug(f"get_visitor_centers returning rate limit error: {result}")
            return result
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_visitor_centers returning HTTP error: {result}")
        return result
    except httpx.RequestError as e:
        error_msg = f"Request error: {e}"
        get_logger().error(f"get_visitor_centers request error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_visitor_centers returning request error: {result}")
        return result
    except Exception as e:
        error_msg = f"Unexpected error: {e}"
        get_logger().error(f"get_visitor_centers unexpected error: {error_msg}")
        result = json.dumps({"error": error_msg})
        get_logger().debug(f"get_visitor_centers returning unexpected error: {result}")
        return result

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="NPS MCP Server - Provides National Park Service information via MCP protocol",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Transport modes:
  stdio: Communication via stdin/stdout (default) - for local MCP clients
  sse:   Server-Sent Events HTTP server mode - for remote MCP clients

Environment Variables:
  NPS_API_KEY: Your NPS API key (get one at https://www.nps.gov/subjects/developer/get-started.htm)
               If not set, will use DEMO_KEY with limited functionality

Examples:
  python nps_mcp_server.py                    # Run with stdio (default, WARNING level)
  python nps_mcp_server.py --transport stdio  # Explicit stdio mode
  python nps_mcp_server.py --transport sse    # SSE HTTP server mode
  python nps_mcp_server.py --transport sse --port 8080  # Custom port
  python nps_mcp_server.py --transport sse --host 0.0.0.0  # Bind to all interfaces

  # With different logging levels (only affects this server, not dependencies)
  python nps_mcp_server.py --log-level DEBUG  # Enable debug logging for NPS server
  python nps_mcp_server.py --log-level INFO   # Info level and above for NPS server
  python nps_mcp_server.py -l ERROR          # Only errors and critical for NPS server

  # With API key
  NPS_API_KEY=your_api_key_here python nps_mcp_server.py
        """
    )
    
    parser.add_argument(
        "--transport", "-t",
        choices=["stdio", "sse"],
        default="stdio",
        help="Transport mode: stdio (default) or sse (HTTP-based)"
    )
    
    parser.add_argument(
        "--host",
        default="localhost", 
        help="Host to bind to in HTTP mode (default: localhost)"
    )
    
    parser.add_argument(
        "--port", "-p",
        type=int,
        default=3000,
        help="Port to bind to in HTTP mode (default: 3000)"
    )
    
    parser.add_argument(
        "--log-level", "-l",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        default="WARNING",
        help="Set the logging level (default: WARNING)"
    )
    
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_arguments()
    
    # Configure logging based on command line argument  
    configure_logging(args.log_level)
    
    # Test that our logger is working (only in DEBUG mode)
    if args.log_level == "DEBUG":
        get_logger().debug("NPS server logging initialized at DEBUG level")
        get_logger().info("Ready to log tool invocations and API calls")
    
    print("Starting MCP NPS Server...")
    print(f"Logging level: {args.log_level}")
    print("Available tools:")
    print("- search_parks: Search for national parks by state, park code, or query")
    print("- get_park_alerts: Get current alerts for a specific park")
    print("- get_park_campgrounds: Get campground information for a park")
    print("- get_park_events: Get upcoming events for a park")
    print("- get_visitor_centers: Get visitor center information for a park")
    
    # Check API key
    api_key = get_api_key()
    if api_key == "DEMO_KEY":
        print("\n‚ö†Ô∏è  Using DEMO_KEY - limited functionality")
        print("   Get a free API key at: https://www.nps.gov/subjects/developer/get-started.htm")
        print("   Set it with: export NPS_API_KEY=your_api_key_here")
    else:
        print(f"\n‚úÖ Using API key: {api_key[:3]}...")
    
    if args.transport == "stdio":
        print("\nüîó Transport: STDIO")
        print("This server communicates via stdin/stdout.")
        print("Connect to it using an MCP client running as a subprocess.")
        print("\nExample usage from an agent:")
        print('  Agent(server_specs="nps_mcp_server.py")')
        
        # Using 'stdio' transport for local communication with a client running as a subprocess
        mcp.run(transport="stdio")
        
    elif args.transport == "sse":
        print("\nüåê Transport: SSE (HTTP-based)")
        print(f"Server will be available at: http://{args.host}:{args.port}")
        print("Connect to it using a remote MCP client.")
        print("\nExample usage from an agent:")
        print(f'  Agent(server_specs="remote:http://{args.host}:{args.port}")')
        print("\nExample test commands:")
        print("  # Test the remote server")
        print(f"  python openai_mcp_agent.py --server remote:http://{args.host}:{args.port}")
        print("\nüöÄ Starting SSE server...")
        
        # Using 'sse' transport for remote communication
        # The newer FastMCP library supports host and port parameters
        try:
            mcp.run(transport="sse", host=args.host, port=args.port)
        except Exception as e:
            print(f"Error starting SSE server: {e}")
            if "address already in use" in str(e).lower() or "errno 48" in str(e).lower():
                print(f"\nüí° Port {args.port} is already in use. Try:")
                print(f"  1. Check what's using port {args.port}: lsof -i :{args.port}")
                print("  2. Kill the existing process: kill <PID>")
                print("  3. Try a different port: python nps_mcp_server.py --transport sse --port <different_port>")
                print("  4. Or use stdio mode: python nps_mcp_server.py --transport stdio")
            else:
                print("Please check the error message above and try again.")
    
    print("\nServer stopped.")
